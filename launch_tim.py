#!/usr/bin/env python
# -*- encoding: utf-8 -*-
"""
Runs a tim experiment(c)
"""
from argparse import ArgumentParser
import random
import pexpect

# Seed the launcher
random.seed(0xbadcafe)

# Command line args parsing
PARSER = ArgumentParser(description="Launching tim script")
PARSER.add_argument("-t", "--tim", default=None,
                    help="tim file (default: autogenerated)")
PARSER.add_argument("-j", "--job-count", type=int, default=1000,
                    help="if tim is autogenerated, create this many jobs, "
                         "default:1000")
PARSER.add_argument("-g", "--gs-structure", default="4:4:4:4:4",
                    help="The setup of how many resource managers what grid "
                         "scheduler has (default 4:4:4:4:4)")
PARSER.add_argument("-f", "--frontend", choices=['none', 'glenn', 'jelmer'],
                    default='none', help="which frontend is started, "
                    "default:none")
PARSER.add_argument("-n", "--nodes", type=int, default=50,
                    help="number of nodes per cluster (default:50)")
PARSER.add_argument("-p", "--port", type=int, default=1337,
                    help="RMI port (default: 1337)")
ARGS = PARSER.parse_args()

processes = []
global_log = open("tim.log", 'wb+')

def java_process(program, args, cp='build/classes/java/main', package='distributed.systems.gridscheduler', waitfor=None, log=global_log):
    command = 'java -cp %s %s.%s %s' % (cp, package, program, ' '.join(map(str, args)))
    # print(INFO + "%s" % command)
    jp = pexpect.spawn(command, logfile=log)

    if waitfor:
        jp.expect(waitfor)

    return jp


# Success colour
INFO    = "[\033[34m!\033[0m] "
SUCCESS = "[\033[32m+\033[0m] "
FAILURE = "[\033[31m+\033[0m] "

# Constants
RMI_PORT = ARGS.port
NODES_PER_CLUSTER = ARGS.nodes
RM_PER_GS = [int(x.strip()) for x in ARGS.gs_structure.split(":")]

print(RM_PER_GS)

# Let's first run gradle to build this shit
print(INFO + "Building project")
builder = pexpect.spawn("gradle compileJava")
builder.expect("BUILD SUCCESSFUL")
print(SUCCESS + "Building complete")

# Let's run the registry
print(INFO + "Running registry")
registry = java_process('RegistryHost', [RMI_PORT], waitfor='Started a registry on')
print(SUCCESS + "Registry up\n")

# Let's run the grid schedulers
active_gs = []
names_gs = []

print(INFO + "Running gridschedulers")
for i, count in enumerate(RM_PER_GS):
    gs_name = 'gs%d' % i
    gs = java_process('RemoteGridSchedulerImpl', [gs_name, 'localhost', RMI_PORT] + names_gs,
        waitfor="GridScheduler '%s' has registered itself with the registry at localhost:%d." % (gs_name, RMI_PORT)
    )

    active_gs.append(gs)
    names_gs.append(gs_name)
    print(SUCCESS + "Grid scheduler %s is up" % gs_name)
print("")

if ARGS.frontend == 'jelmer':
    print(INFO + "Running jelmer's baby")
    fe = java_process('TextFrontend', ['Jelmer', 'localhost', RMI_PORT, names_gs[-1]], waitfor="Jelmer is up")
    print(SUCCESS + "Jelmer is a go")
elif ARGS.frontend == 'glenn':
    print(INFO + "Running glenn's baby")
    fe = java_process('Frontend', ['Glenn', 'localhost', RMI_PORT, names_gs[-1]], waitfor="Glenn is up")
    print(SUCCESS + "Glenn is a go")

# Let's run the resource managers
active_rm = []
names_rm = []

print(INFO + "Running resource managers")
for i, count in enumerate(RM_PER_GS):
    gs_name = 'gs%d' % i

    for j in range(count):
        rm_name = '%s-rm%d' % (gs_name, j)

        rm = java_process('RemoteResourceManagerImpl', [rm_name, NODES_PER_CLUSTER, 'localhost', RMI_PORT, gs_name] + [g for g in names_gs if g != gs_name],
            waitfor="ResourceManager '%s' has registered itself with the registry at localhost:%d." % (rm_name, RMI_PORT)
        )

        active_rm.append(rm)
        names_rm.append(rm_name)
        print(SUCCESS + "Resource manager %s is up" % rm_name)
print("")

###############################################################
# REPLACE ME WITH TIM CODE
###############################################################

if ARGS.tim == None:
    # Generate a tim script to run
    print(INFO + "Generating tim")
    with open('test.tim', 'w+') as f:
        f.write("// Auto generated, do not edit\n\n")

        for i in range(ARGS.job_count):
            f.write('%d, %d, %s\n' % (i, random.randint(0, 5), random.choice(names_rm)))
    ARGS.tim = 'test.tim'

print(INFO + "Running multiclient")
tester = java_process('MultiClient', [ARGS.tim, 'localhost', RMI_PORT])
tester.expect('Test complete', timeout=None)
print(SUCCESS + "Test complete")
